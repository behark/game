<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed Rivals - Multiplayer 3D Racing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
            min-width: 200px;
        }

        #chat {
            position: absolute;
            bottom: 80px;
            left: 20px;
            width: 300px;
            height: 150px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #chatMessages {
            flex: 1;
            padding: 10px;
            color: white;
            font-size: 12px;
            overflow-y: auto;
        }

        #chatInput {
            margin: 10px;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.9);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
            text-align: center;
        }

        #connectionStatus {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
            z-index: 150;
        }

        .connected { background: rgba(0,255,0,0.3); }
        .disconnected { background: rgba(255,0,0,0.3); }
        .connecting { background: rgba(255,255,0,0.3); }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="loading">
            <div>üèéÔ∏è Loading Multiplayer Racing...</div>
            <div id="status">Connecting to server...</div>
        </div>

        <div id="connectionStatus" class="connecting">üîÑ Connecting...</div>

        <div id="ui" class="hidden">
            <div id="speed">Speed: <span id="speedValue">0</span> km/h</div>
            <div id="lap">Lap: <span id="lapValue">1</span>/3</div>
            <div id="position">Position: <span id="positionValue">1</span>/4</div>
            <div id="players">Players: <span id="playerCount">1</span>/4</div>
        </div>

        <div id="leaderboard" class="hidden">
            <div style="font-weight: bold; margin-bottom: 10px;">üèÅ Race Standings</div>
            <div id="leaderboardContent">
                <div>1. You - Lap 1</div>
                <div>2. Waiting for players...</div>
            </div>
        </div>

        <div id="chat" class="hidden">
            <div id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Type message..." maxlength="100">
        </div>

        <div id="controls" class="hidden">
            <div><strong>Controls:</strong></div>
            <div>W/‚Üë - Accelerate</div>
            <div>S/‚Üì - Brake/Reverse</div>
            <div>A/‚Üê - Turn Left</div>
            <div>D/‚Üí - Turn Right</div>
            <div>Space - Handbrake</div>
            <div>Enter - Chat</div>
        </div>

        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Socket.io for multiplayer -->
    <script src="/socket.io/socket.io.js"></script>

    <script>
        // Game variables
        let scene, camera, renderer;
        let myCarGroup, otherPlayers = {};
        let socket;
        let keys = {};
        let gameState = {
            speed: 0,
            position: { x: 0, y: 0.1, z: -30 },
            rotation: 0,
            lap: 1,
            racePosition: 1,
            playerName: `Player_${Math.random().toString(36).substring(2, 8)}`
        };

        const carPhysics = {
            speed: 0,
            angle: 0,
            maxSpeed: 0.8,
            acceleration: 0.03,
            turnSpeed: 0.04,
            friction: 0.02
        };

        // Update status
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('üéÆ', message);
        }

        // Initialize multiplayer connection
        function initMultiplayer() {
            updateStatus('Connecting to server...');

            socket = io();

            socket.on('connect', () => {
                updateStatus('Connected! Joining game...');
                document.getElementById('connectionStatus').textContent = '‚úÖ Connected';
                document.getElementById('connectionStatus').className = 'connected';

                // Join the game
                socket.emit('joinGame', {
                    name: gameState.playerName,
                    carColor: 0xff4444
                });
            });

            socket.on('disconnect', () => {
                document.getElementById('connectionStatus').textContent = '‚ùå Disconnected';
                document.getElementById('connectionStatus').className = 'disconnected';
            });

            socket.on('gameJoined', (data) => {
                updateStatus('Game joined! Loading 3D world...');
                gameState.playerId = data.playerId;
                setTimeout(initGame, 500);
            });

            socket.on('playerJoined', (player) => {
                addChatMessage(`${player.name} joined the race! üèéÔ∏è`);
                updatePlayerCount();
            });

            socket.on('playerLeft', (data) => {
                addChatMessage(`${data.playerName} left the race üëã`);
                if (otherPlayers[data.playerId]) {
                    scene.remove(otherPlayers[data.playerId]);
                    delete otherPlayers[data.playerId];
                }
                updatePlayerCount();
            });

            socket.on('playerUpdate', (data) => {
                updateOtherPlayer(data);
            });

            socket.on('roomState', (roomState) => {
                updateLeaderboard(roomState.players);
                document.getElementById('playerCount').textContent = roomState.playerCount;
            });

            socket.on('chatMessage', (data) => {
                addChatMessage(`${data.playerName}: ${data.message}`);
            });

            socket.on('raceCountdown', (data) => {
                updateStatus(`Race starts in ${data.count}!`);
            });

            socket.on('raceStarted', () => {
                addChatMessage('üèÅ Race started! GO GO GO!');
            });
        }

        // Create car model
        function createCar(color = 0xff4444) {
            const carGroup = new THREE.Group();

            // Car body
            const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 4);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = 0.4;
            bodyMesh.castShadow = true;
            carGroup.add(bodyMesh);

            // Car roof
            const roofGeometry = new THREE.BoxGeometry(1.6, 0.6, 2);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
            roofMesh.position.y = 1;
            roofMesh.castShadow = true;
            carGroup.add(roofMesh);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });

            const wheelPositions = [
                { x: -0.9, y: 0, z: 1.3 },
                { x: 0.9, y: 0, z: 1.3 },
                { x: -0.9, y: 0, z: -1.3 },
                { x: 0.9, y: 0, z: -1.3 }
            ];

            wheelPositions.forEach(pos => {
                const wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheelMesh.position.set(pos.x, pos.y, pos.z);
                wheelMesh.rotation.z = Math.PI / 2;
                wheelMesh.castShadow = true;
                carGroup.add(wheelMesh);
            });

            // Headlights
            const lightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffcc,
                emissive: 0x444422
            });

            const leftLight = new THREE.Mesh(lightGeometry, lightMaterial);
            leftLight.position.set(-0.6, 0.5, 1.9);
            carGroup.add(leftLight);

            const rightLight = new THREE.Mesh(lightGeometry, lightMaterial);
            rightLight.position.set(0.6, 0.5, 1.9);
            carGroup.add(rightLight);

            return carGroup;
        }

        // Initialize game
        function initGame() {
            updateStatus('Creating 3D scene...');

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 15);

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            updateStatus('Adding lights and track...');

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 25);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Create track
            const trackGeometry = new THREE.RingGeometry(25, 45, 32);
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            trackMesh.rotation.x = -Math.PI / 2;
            trackMesh.position.y = 0.01;
            scene.add(trackMesh);

            // Track center line
            const lineGeometry = new THREE.RingGeometry(34, 36, 32);
            const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const lineMesh = new THREE.Mesh(lineGeometry, lineMaterial);
            lineMesh.rotation.x = -Math.PI / 2;
            lineMesh.position.y = 0.02;
            scene.add(lineMesh);

            updateStatus('Creating your car...');

            // Create player's car
            myCarGroup = createCar(0xff4444);
            myCarGroup.position.set(gameState.position.x, gameState.position.y, gameState.position.z);
            scene.add(myCarGroup);

            updateStatus('Setting up controls...');

            // Setup controls
            setupControls();

            updateStatus('Ready to race! üèÅ');

            // Show game UI
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('ui').classList.remove('hidden');
                document.getElementById('leaderboard').classList.remove('hidden');
                document.getElementById('chat').classList.remove('hidden');
                document.getElementById('controls').classList.remove('hidden');

                addChatMessage('üéÆ Welcome to Speed Rivals multiplayer!');
                addChatMessage('üí¨ Press Enter to chat with other players');

                // Start game loop
                gameLoop();
            }, 1000);
        }

        // Setup controls
        function setupControls() {
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'Space') e.preventDefault();
                if (e.code === 'Enter') {
                    e.preventDefault();
                    document.getElementById('chatInput').focus();
                }
            });

            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Chat input
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const message = e.target.value.trim();
                    if (message && socket) {
                        socket.emit('chatMessage', message);
                        e.target.value = '';
                        e.target.blur();
                    }
                }
            });

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Update other players
        function updateOtherPlayer(data) {
            if (data.playerId === gameState.playerId) return;

            if (!otherPlayers[data.playerId]) {
                // Create new player car
                otherPlayers[data.playerId] = createCar(data.carColor || 0x4444ff);
                scene.add(otherPlayers[data.playerId]);
            }

            // Update position
            const playerCar = otherPlayers[data.playerId];
            playerCar.position.lerp(
                new THREE.Vector3(data.position.x, data.position.y, data.position.z),
                0.3
            );
            playerCar.rotation.y = data.rotation;
        }

        // Add chat message
        function addChatMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.textContent = message;
            messageElement.style.marginBottom = '5px';
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Keep only last 50 messages
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }

        // Update leaderboard
        function updateLeaderboard(players) {
            const content = document.getElementById('leaderboardContent');
            content.innerHTML = '';

            players.sort((a, b) => {
                if (a.lap !== b.lap) return b.lap - a.lap;
                return b.position.z - a.position.z; // Closer to finish line
            });

            players.forEach((player, index) => {
                const div = document.createElement('div');
                div.textContent = `${index + 1}. ${player.name} - Lap ${player.lap}`;
                if (player.id === gameState.playerId) {
                    div.style.color = '#ffff00';
                    div.style.fontWeight = 'bold';
                }
                content.appendChild(div);
            });
        }

        // Update player count
        function updatePlayerCount() {
            // This will be updated by roomState event
        }

        // Update game logic
        function updateGame() {
            // Handle input
            if (keys['KeyW'] || keys['ArrowUp']) {
                carPhysics.speed = Math.min(carPhysics.speed + carPhysics.acceleration, carPhysics.maxSpeed);
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                carPhysics.speed = Math.max(carPhysics.speed - carPhysics.acceleration, -carPhysics.maxSpeed / 2);
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                carPhysics.angle -= carPhysics.turnSpeed * Math.abs(carPhysics.speed / carPhysics.maxSpeed);
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                carPhysics.angle += carPhysics.turnSpeed * Math.abs(carPhysics.speed / carPhysics.maxSpeed);
            }
            if (keys['Space']) {
                carPhysics.speed *= 0.9;
            }

            // Apply friction
            carPhysics.speed *= (1 - carPhysics.friction);

            // Update position
            gameState.position.x += Math.sin(carPhysics.angle) * carPhysics.speed;
            gameState.position.z += Math.cos(carPhysics.angle) * carPhysics.speed;
            gameState.rotation = carPhysics.angle;

            // Update car position
            myCarGroup.position.set(gameState.position.x, gameState.position.y, gameState.position.z);
            myCarGroup.rotation.y = carPhysics.angle;

            // Update camera
            const cameraDistance = 20;
            const cameraHeight = 12;
            const targetX = gameState.position.x - Math.sin(carPhysics.angle) * cameraDistance;
            const targetZ = gameState.position.z - Math.cos(carPhysics.angle) * cameraDistance;

            camera.position.lerp(
                new THREE.Vector3(targetX, gameState.position.y + cameraHeight, targetZ),
                0.1
            );
            camera.lookAt(gameState.position.x, gameState.position.y + 2, gameState.position.z);

            // Update UI
            gameState.speed = Math.abs(carPhysics.speed) * 120;
            document.getElementById('speedValue').textContent = Math.round(gameState.speed);

            // Send position to server
            if (socket && socket.connected) {
                socket.emit('playerUpdate', {
                    position: gameState.position,
                    rotation: gameState.rotation,
                    speed: gameState.speed,
                    lap: gameState.lap
                });
            }
        }

        // Game loop
        function gameLoop() {
            updateGame();
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        // Start initialization
        initMultiplayer();
    </script>
</body>
</html>